import Levenshtein as lev
import pandas as pd
from geopy.distance import geodesic
from functools import wraps
from time import time
import os

DISTANCE_THRESHOLD = 200
CHAR_THRESHOLD = 5


def timeit(f):
    @wraps(f)
    def wrapper(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print(f'func:{f.__name__}  took: {te - ts: 2.4f} sec')
        return result

    return wrapper


def clean(city_name):
    city_name = city_name.lower()
    city_name = city_name.replace(' ', '')
    return city_name


@timeit
def get_similarity_and_distance(file_name, out_path):
    """
    :param file_name: output file name
    :param out_path: output directory
    :return:

    function will iterate through given csv file and calculate similarity and distance of current city  with all
    next city  based on conditions put on
    CHAR_THRESHOLD(max no of updatable chars) and
    DISTANCE_THRESHOLD(max distance between two cities) (calculated using geopy library)
    and if the cities are within threshold limits then will put the info in csv file(output/similar_cities.csv)
    """

    df = pd.read_csv("assignment_data.csv")
    records = df.to_dict(orient='records')     # list of rows as key,value dictionaries
    similar_cities = pd.DataFrame(columns=['name1', 'name2', 'similarity', 'distance']) # Empty data frame to store similar cities
    os.makedirs(out_path, exist_ok=True)
    file_name = os.path.join(out_path, file_name)
    count = 0
    for i in range(len(records)):
        for j in range(i + 1, len(records)):
            name1, lat1, long1 = records[i].values()   # getting city_name,latitude,longitude from row dictionary
            name2, lat2, long2 = records[j].values()
            if abs(len(name1) - len(name2)) >= CHAR_THRESHOLD:  # if difference in length b/w two names>=threshold then not similar
                continue
            similarity = lev.distance(clean(name1), clean(name2))   # getting no. of char updates to convert one string to another using Levenshtein algo
            if similarity >= CHAR_THRESHOLD:
                continue
            distance = geodesic((lat1, long1), (lat2, long2)).meters    # getting distance b/w the coordinates of the two cities
            if distance > DISTANCE_THRESHOLD:                           # checking ifdistance is within DISTANCE_THRESHOLD
                continue
            similar_cities.loc[similar_cities.shape[0]] = [clean(name1), clean(name2), similarity, distance]
            count += 1
            if count % 100 == 0:
                similar_cities.to_csv(file_name, index=False)
                print(f"Inserted {count} records")
    similar_cities.to_csv(file_name, index=False)
    print(f"Inserted {count} records")


@timeit
def mark_similar(similar_cities_file_name, out_path):
    """
    :param similar_cities_file_name: file generated by function <get_similarity_and_distance>
    :param out_path: output_directory
    :return:

    This function will iterate through city_info_file(original assignment file) and check if the city name is present
    in the <similar_cities_file_name> file and if the city name is present it means there is another city that is
    similar to current city and will mark is_similar as 1
    and save the final dataframe to output/Final Result.csv file
    """

    def check_similar(name):
        return similar_cities[(similar_cities['name1'] == name) | (similar_cities['name2'] == name)].shape[0] > 0

    similar_cities = pd.read_csv(f'{out_path}/{similar_cities_file_name}')
    cities_data = pd.read_csv('assignment_data.csv')
    cities_data["is_similar"] = cities_data['name'].apply(lambda name: int(check_similar(clean(name))))
    cities_data.to_csv(f"{out_path}/Final Result.csv", index=False)


if __name__ == "__main__":
    similar_cities_file_name = 'similar_cities.csv'
    output_directory = 'output'
    get_similarity_and_distance(similar_cities_file_name, output_directory)    # matching similar cities
    mark_similar(similar_cities_file_name, output_directory)                   # marking is_similar
